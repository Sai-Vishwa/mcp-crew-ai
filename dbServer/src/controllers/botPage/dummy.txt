SELECT 
    t.id,
    t.name,
    t.description,
    CASE 
        WHEN a.tool_id IS NOT NULL OR sa.tool_id IS NOT NULL THEN TRUE
        ELSE FALSE
    END AS access_status
FROM tools t
LEFT JOIN auth u ON u.uname = 'TeTeacher2'
LEFT JOIN access a 
    ON a.tool_id = t.id AND a.user_type = u.role
LEFT JOIN specialaccess sa 
    ON sa.tool_id = t.id AND sa.uname = u.uname;




SELECT 
    CASE 
        WHEN EXISTS (
            SELECT 1
            FROM session s
            JOIN auth a ON s.uname = a.uname
            JOIN tools t ON t.name = 'Create_Placement'
            LEFT JOIN access ra ON ra.user_type = a.role AND ra.tool_id = t.id
            LEFT JOIN specialaccess sa ON sa.uname = a.uname AND sa.tool_id = t.id
            WHERE s.session = 'abcd'
              AND (ra.tool_id IS NOT NULL OR sa.tool_id IS NOT NULL)
        )
        THEN 'YES'
        ELSE 'NO'
    END AS access_result;



















    [StructuredTool(name='CreatePlacement', description='This tool is used to create a new placement entry or update an existing one in the database', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session identifier'}, 'company_name': {'type': 'string', 'description': 'Name of the company'}, 'visiting_date': {'type': 'string', 'description': 'Date of the company visit'}, 'interview_start': {'type': 'string', 'description': 'Interview start time (HH:MM:SS)'}, 'interview_end': {'type': 'string', 'description': 'Interview end time (HH:MM:SS)'}}, 'required': ['session', 'company_name', 'visiting_date', 'interview_start', 'interview_end']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54ddf42480>), StructuredTool(name='DeletePlacement', description='This tool is used to delete a placement entry from the database with the name of the organisation been provided', args_schema={'type': 'object', 'properties': {'company_name': {'type': 'string', 'description': 'Name of the company whose placement entry to be deleted'}, 'session': {'type': 'string', 'description': 'Session identifier'}}, 'required': ['company_name', 'session']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54ddf93ec0>), StructuredTool(name='example_tool', description='An example tool that processes messages', args_schema={'type': 'object', 'properties': {'message': {'type': 'string', 'description': 'Message to process'}}, 'required': ['message']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54ddf93f60>), StructuredTool(name='ReadPlacement', description='This tool is used to read placement entries', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session identifier'}}, 'required': ['session']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63e700>), StructuredTool(name='CreateExam', description='This tool is used to create a new exam entry or update an existing one in the database', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session identifier'}, 'exam_date': {'type': 'string', 'description': 'Date of the Exam'}, 'exam_start': {'type': 'string', 'description': 'Exam start time (HH:MM:SS)'}, 'exam_end': {'type': 'string', 'description': 'Exam end time (HH:MM:SS)'}}, 'required': ['session', 'exam_date', 'exam_start', 'exam_end']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63ca40>), StructuredTool(name='DeleteExam', description='This tool is used to delete an exam entry from the database with the date of the exam being provided', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session identifier'}, 'exam_date': {'type': 'string', 'description': 'Date of the exam to be deleted'}}, 'required': ['session', 'exam_date']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63f600>), StructuredTool(name='example_tool', description='An example tool that processes messages', args_schema={'type': 'object', 'properties': {'message': {'type': 'string', 'description': 'Message to process'}}, 'required': ['message']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63ede0>), StructuredTool(name='ReadExam', description='This tool is used to read all exam schedule entries', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session identifier'}}, 'required': ['session']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63d8a0>), StructuredTool(name='CreateTransport', description='This tool is used to create a new transport entry or update an existing one in the database', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session identifier'}, 'bus_date': {'type': 'string', 'description': 'Date for which the bus details is to be entered'}, 'start_time': {'type': 'string', 'description': 'time when busses start (HH:MM:SS)'}, 'leave_time': {'type': 'string', 'description': 'time when busses leave (HH:MM:SS)'}}, 'required': ['session', 'bus_date', 'start_time', 'leave_time']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63ccc0>), StructuredTool(name='DeleteTransport', description='This tool is used to delete a transport entry for a corresponding date provided', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'Session Identifier'}, 'bus_date': {'type': 'string', 'description': 'Date for which the bus details is to be deleted'}}, 'required': ['session', 'bus_date']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63d9e0>), StructuredTool(name='example_tool', description='An example tool that processes messages', args_schema={'type': 'object', 'properties': {'message': {'type': 'string', 'description': 'Message to process'}}, 'required': ['message']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63ec00>), StructuredTool(name='ReadTransport', description='This tool is used to read all transport entries', args_schema={'type': 'object', 'properties': {'session': {'type': 'string', 'description': 'session indentifier'}}, 'required': ['session']}, response_format='content_and_artifact', coroutine=<function convert_mcp_tool_to_langchain_tool.<locals>.call_tool at 0x7b54dc63fc40>)]
prompt=PromptTemplate(input_variables=['\n  "workflow"'], input_types={}, partial_variables={}, template='You are a reasoning agent that converts natural language user requests into a JSON workflow of tool invocations.  \nYou will ALWAYS respond with valid JSON only, no explanations, no natural language.  \n\n## Rules:\n1. Your output must be a JSON object with this structure:\n   {{\n     "workflow": [\n       {{\n         "step": <number>,\n         "tool": "<ToolName>",\n         "args": {{\n            "<arg1>": "<value>",\n            "<arg2>": "<value>"\n         }}\n       }},\n       ...\n     ]\n   }}\n\n2. Tools available will be injected at runtime.  \n   - Do not hallucinate new tools.  \n   - Only use tools that are provided at runtime.  \n\n3. Every workflow must include correct sequencing.  \n   - Example: To update something, first **read**, then **delete/update**, then **create**.  \n   - If data consistency is needed (e.g., updating exam + transport), chain related tools step by step.  \n\n4. `args` must strictly follow the tool’s schema.  \n   - If you don’t know a value from user input, leave it as an empty string `""`.  \n\n5. Do NOT include comments, natural language, or explanations in your response. Output JSON only.  \n\n## Example:\nUser: "update the exam schedule from 4th sept to 5th sept"  \nOutput:\n{\n  "workflow": [\n    {{\n      "step": 1,\n      "tool": "ReadExam",\n      "args": {{\n        "session": "",\n        "exam_date": "4th sept"\n      }}\n    }},\n    {{\n      "step": 2,\n      "tool": "DeleteExam",\n      "args": {{\n        "session": "",\n        "exam_date": "4th sept"\n      }}\n    }},\n    {{\n      "step": 3,\n      "tool": "CreateExam",\n      "args": {{\n        "session": "",\n        "exam_date": "5th sept",\n        "exam_start": "",\n        "exam_end": ""\n      }}\n    }},\n    {\n      "step": 4,\n      "tool": "CreateTransport",\n      "args": {\n        "session": "",\n        \n      }\n    },\n    {\n      "step": 5,\n      "tool": "UpdateTransport",\n      "args": {\n        "session": ""\n      }\n    }\n  ]\n}\n') additional_kwargs={}
/home/sai-nts0033/Desktop/mcp-crew-ai/langGraphServer/app/controllers/langgraph/lang_graph.py:103: LangChainDeprecationWarning: LangChain agents will continue to be supported, but it is recommended for new use cases to be built with LangGraph. LangGraph offers a more flexible and full-featured framework for building agents, including support for tool-calling, persistence of state, and human-in-the-loop workflows. For details, refer to the `LangGraph documentation <https://langchain-ai.github.io/langgraph/>`_ as well as guides for `Migrating from AgentExecutor <https://python.langchain.com/docs/how_to/migrate_agent/>`_ and LangGraph's `Pre-built ReAct agent <https://langchain-ai.github.io/langgraph/how-tos/create-react-agent/>`_.
  reasoning_agent = initialize_agent(


